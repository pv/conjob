#!/usr/bin/env python
import os, sys, time, optparse, configobj, signal

CFGFILE = os.path.expanduser("~/.conjob")

def _is_running(pid):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/stat' % dr)
        try:
            x = f.read().split()
            return (x[2] == 'R')
        finally:
            f.close()
    else:
        return False

def _stop_process(pid):
    os.kill(pid, signal.SIGSTOP)

def _continue_process(pid):
    os.kill(pid, signal.SIGCONT)

class PidScheduler(object):
    def __init__(self, filename):
        self.pids = []
        self.cfg = configobj.ConfigObj(filename)
        self.cfg.setdefault('pidlist', filename + '.pids')
        self.cfg.setdefault('nprocs', 2)
        self.load_pids()
    
    def load_pids(self):
        cfg = configobj.ConfigObj(self.cfg['pidlist'])
        for key, value in cfg.iteritems():
            try:
                pid = int(key)
                priority = float(value)
                self.pids.append((pid, priority))
            except ValueError:
                continue

    def save_pids(self):
        cfg = configobj.ConfigObj()
        cfg.filename = self.cfg['pidlist']
        for pid, prio in self.pids:
            cfg[str(pid)] = prio
        cfg.write()

    def save(self):
        self.cfg.write()
        self.save_pids()
    
    def add(self, pid, prio):
        for i, (key, value) in enumerate(self.pids):
            if key == pid:
                self.pids[i] = (pid, prio)
                return
        self.pids.append((pid, prio))

    def remove(self, pid):
        vals = [z for z in self.pids if z[0] == pid]
        if vals:
            for v in vals:
                self.pids.remove(v)

    def _update(self):
        self.pids = [z for z in self.pids if _is_running(z[0])]

    def schedule(self):
        def _cmp_prio(a, b):
            return cmp(a[1], b[1])

        # Check status
        self._update()

        # Sort
        self.pids.sort(_cmp_prio)
        nprocs = int(self.cfg['nprocs'])

        # Stop / continue
        to_run = self.pids[:nprocs]
        to_stop = self.pids[nprocs:]

        for pid, prio in to_run:
            _continue_process(pid)

        for pid, prio in to_stop:
            _stop_process(pid)

        self.save_pids()

def do_add(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.add(pid, 0)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()
    
def do_remove(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.remove(pid)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()

def do_schedule(sched, p):
    sched.schedule()

def do_setprio(sched, p):
    try:
        pid = int(p.args[0])
        prio = float(p.args[1])
    except ValueError:
        p.error("pid, prio not given")
    sched.remove(pid)
    sched.add(pid, prio)
    sched.save()

def do_list(sched, p):
    for pid, prio in sched.pids:
        print "%8d  %.2g" % (pid, prio)

def main():
    help = """
commands:
  add PID             Add a PID to the schedule list
  remove PID          Remove a PID from the schedule list
  list                List scheduled PIDs
  schedule            Perfom scheduling, starting/stopping processes
  setprio PID PRIO    Set a priority for a PID
""".strip()
    
    p = optparse.OptionParser("%prog [options] command [PIDS...]\n\n" + help)
    (options, args) = p.parse_args()

    if len(args) < 1:
        p.error("No command given")

    sched = PidScheduler(CFGFILE)

    cmds = dict(add=do_add,
                schedule=do_schedule,
                remove=do_remove,
                setprio=do_setprio,
                list=do_list)

    cmd = args.pop(0)
    func = cmds.get(cmd)

    p.args = args
    p.options = options
    if func is None:
        p.error("Unknown command %s" % cmd)
    else:
        func(sched, p)
    
if __name__ == "__main__":
    main()
