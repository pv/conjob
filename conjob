#!/usr/bin/env python2.4
# -*-python-*-
import os, sys, time, optparse, signal, configobj

CFGFILE = os.path.expanduser("~/.conjob")

def _is_running(pid, accept_stopped=False):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/stat' % dr)
        try:
            x = f.read().split()
            if accept_stopped:
                return (x[2] == 'R') or (x[2] == 'T')
            else:
                return (x[2] == 'R')
        finally:
            f.close()
    else:
        return False

def _cmdline(pid):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/cmdline' % dr)
        try:
            cmdline = f.read().split("\0")
            if cmdline[-1] == '':
                cmdline.pop()
            return cmdline
        finally:
            f.close()
    else:
        return []

def _stop_process(pid):
    os.kill(pid, signal.SIGSTOP)

def _continue_process(pid):
    os.kill(pid, signal.SIGCONT)

class PidScheduler(object):
    def __init__(self, filename):
        self.pids = []
        self.cfg = configobj.ConfigObj(filename)
        self.cfg.setdefault('pidlist', filename + '.pids')
        self.cfg.setdefault('nprocs', 2)
        self.load_pids()
    
    def load_pids(self):
        cfg = configobj.ConfigObj(self.cfg['pidlist'])
        for key, value in cfg.iteritems():
            try:
                pid = int(key)
                priority = float(value)
                self.pids.append((pid, priority))
            except ValueError:
                continue

    def save_pids(self):
        cfg = configobj.ConfigObj()
        cfg.filename = self.cfg['pidlist']
        for pid, prio in self.pids:
            cfg[str(pid)] = prio
        cfg.write()

    def save(self):
        self.save_pids()
    
    def add(self, pid, prio):
        for i, (key, value) in enumerate(self.pids):
            if key == pid:
                self.pids[i] = (pid, prio)
                return
        self.pids.append((pid, prio))

    def remove(self, pid):
        vals = [z for z in self.pids if z[0] == pid]
        if vals:
            for v in vals:
                self.pids.remove(v)

    def _update(self):
        self.pids = [z for z in self.pids if _is_running(z[0], True)]

    def schedule(self):
        def _cmp_prio(a, b):
            return cmp(a[1], b[1])

        # Check status
        self._update()

        # Sort
        self.pids.sort(_cmp_prio, reverse=True)
        nprocs = int(self.cfg['nprocs'])

        # Stop / continue
        to_run = self.pids[:nprocs]
        to_stop = self.pids[nprocs:]

        for pid, prio in to_run:
            _continue_process(pid)

        for pid, prio in to_stop:
            _stop_process(pid)

        self.save_pids()

def do_add(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.add(pid, 0)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()
    
def do_remove(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.remove(pid)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()

def do_schedule(sched, p):
    sched.schedule()

def do_setprio(sched, p):
    try:
        pid = int(p.args[0])
        prio = float(p.args[1])
    except ValueError:
        p.error("pid, prio not given")
    sched.remove(pid)
    sched.add(pid, prio)
    sched.save()

def do_list(sched, p):
    for pid, prio in sched.pids:
        mark = " "
        if _is_running(pid, False):
            mark = "*"
        cmdline = ' '.join(_cmdline(pid))
        print "%8d%s  %.2g  %s" % (pid, mark, prio, cmdline)

def do_run(sched, p):
    parent_pid = os.getpid()
    pid = os.fork()
    if pid < 0:
        raise RuntimeError("Failed to fork the process")
    elif pid == 0:
        # child
        print "Adding job PID %d" % parent_pid
        sched.add(parent_pid, 0)
        sched.save()
        sys.exit(0)
    else:
        # parent
        _stop_process(os.getpid())
        os.execvp(p.args[0], p.args)
        raise RuntimeError("Failed to execute command '%s'" % p.args)

def do_run_bg(sched, p):
    pid = os.fork()
    if pid < 0:
        raise RuntimeError("Failed to fork the process")
    elif pid == 0:
        # child
        time.sleep(0.1)

        # invoke in background
        os.setsid()        # new process group
        sys.stdin.close()  # close inherited IO handles
        sys.stdout.close()
        sys.stderr.close()

        os.execvp(p.args[0], p.args)
        raise RuntimeError("Failed to execute command '%s'" % p.args)
    else:
        # parent
        _stop_process(pid)
        print "Adding job PID %d" % pid
        sched.add(pid, 0)
        sched.save()
        sys.exit(0)

def main(argv):
    help = """
Process job controller, letting a limited number of jobs run at the same
time.
    
commands:
  add PID             Add a PID to the schedule list
  remove PID          Remove a PID from the schedule list
  list                List scheduled PIDs
  schedule            Perfom scheduling, starting/stopping processes
  setprio PID PRIO    Set a priority for a PID
  run CMD             Run a command and put the process in the queue
  bg CMD              Run a command in the background and insert to queue
""".strip()
    
    p = optparse.OptionParser("%prog [options] command [PIDS...]\n\n" + help)
    p.allow_interspersed_args = False
    (options, args) = p.parse_args(argv)

    if len(args) < 1:
        p.error("No command given")

    sched = PidScheduler(CFGFILE)

    cmds = dict(add=do_add,
                schedule=do_schedule,
                remove=do_remove,
                setprio=do_setprio,
                list=do_list,
                run=do_run,
                bg=do_run_bg,
                ls=do_list,
                rm=do_remove)

    cmd = args.pop(0)
    func = cmds.get(cmd)

    p.args = args
    p.options = options
    if func is None:
        p.error("Unknown command %s" % cmd)
    else:
        func(sched, p)
    
if __name__ == "__main__":
    main(sys.argv[1:])
