#!/usr/bin/env python2.5
# -*-python-*-
import os, sys, time, optparse, signal, configobj, tempfile, shutil, glob, re

CFGFILE = os.path.expanduser("~/.conjob")

def _is_running(pid, accept_stopped=False):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/stat' % dr)
        try:
            x = f.read().split()
            if accept_stopped:
                return True
            else:
                return (x[2] != 'T')
        finally:
            f.close()
    else:
        return False

def _mem_usage(pid):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/status' % dr)
        try:
            lines = f.read().split("\n")
            for line in lines:
                m = re.match(r'^VmSize:\s*(\d+) kB$', line)
                if m:
                    return float(m.group(1))
        finally:
            f.close()
    return 0    

def _total_mem():
    f = open('/proc/meminfo', 'r')
    try:
        lines = f.read().split("\n")
        for line in lines:
            m = re.match(r'^MemTotal:\s*(\d+) kB$', line)
            if m:
                return float(m.group(1))
    finally:
        f.close()
    return 1e99

def _get_loadavg():
    f = open('/proc/loadavg', 'r')
    try:
        data = f.read()
        return float(data.split()[0])
    finally:
        f.close()

def _cmdline(pid):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/cmdline' % dr)
        try:
            cmdline = f.read().split("\0")
            if cmdline[-1] == '':
                cmdline.pop()
            return cmdline
        finally:
            f.close()
    else:
        return []

def _nice_cmdline(pid):
    cmdline = _cmdline(pid)
    for arg in (sys.argv[0], 'conjob'):
        if arg in cmdline:
            cmdline = cmdline[cmdline.index(arg)+2:]
            break
    if cmdline and cmdline[0].startswith('python2.'):
        cmdline.pop(0)
    return cmdline

def _stop_process(pid):
    os.kill(pid, signal.SIGSTOP)

def _continue_process(pid):
    os.kill(pid, signal.SIGCONT)

def _set_ioprio(pid, ioprio=0):
    """
    Set IO priority
    """
    os.system('ionice -p %d -n %d' % (pid, ioprio))

class PidScheduler(object):
    def __init__(self, filename):
        self.pids = []
        self.cfg = configobj.ConfigObj(filename)
        self.cfg.setdefault('logdir', filename + '.log')
        self.cfg.setdefault('pidlist', filename + '.pids')
        self.cfg.setdefault('nprocs', 2)
        self.cfg.setdefault('nice', 10)
        self.cfg.setdefault('ioprio', 7)
        self.cfg.setdefault('loadavg', 2)
        self.cfg.setdefault('max_mem_percentage', 75)
        self.cfg['nice'] = int(self.cfg['nice'])
        self.cfg['ioprio'] = int(self.cfg['ioprio'])
        self.cfg['nprocs'] = int(self.cfg['nprocs'])
        self.cfg['loadavg'] = float(self.cfg['loadavg'])
        self.cfg['pidlist'] = str(self.cfg['pidlist'])
        self.cfg['logdir'] = str(self.cfg['logdir'])
        self.cfg['max_mem_percentage'] = float(self.cfg['max_mem_percentage'])
        self.load_pids()

        if not os.path.isdir(self.cfg['logdir']):
            os.makedirs(self.cfg['logdir'])
    
    def load_pids(self):
        cfg = configobj.ConfigObj(self.cfg['pidlist'])
        for key, value in cfg.iteritems():
            try:
                pid = int(key)
                priority = float(value)
                self.pids.append((pid, priority))
            except ValueError:
                continue

    def save_pids(self):
        # avoid write races by writing to a temp file and overwriting
        # by moving (which probably is atomic within a FS)
        fd, tmp_fn = tempfile.mkstemp(
                prefix=os.path.basename(self.cfg['pidlist']),
                dir=os.path.dirname(self.cfg['pidlist']))
        cfg = configobj.ConfigObj()
        cfg.filename = tmp_fn
        for pid, prio in self.pids:
            cfg[str(pid)] = prio
        cfg.write()
        shutil.move(tmp_fn, self.cfg['pidlist'])

    def save(self):
        self.save_pids()
    
    def add(self, pid, prio):
        for i, (key, value) in enumerate(self.pids):
            if key == pid:
                self.pids[i] = (pid, prio)
                return
        self.pids.append((pid, prio))

    def remove(self, pid):
        vals = [z for z in self.pids if z[0] == pid]
        if vals:
            for v in vals:
                self.pids.remove(v)

    def _update(self):
        self.pids = [z for z in self.pids if _is_running(z[0], True)]

    def schedule(self):
        def _cmp_prio(a, b):
            return cmp(a[1], b[1])

        # Check status
        self._update()

        # Sort
        self.pids.sort(_cmp_prio, reverse=True)
        nprocs = self.cfg['nprocs']

        # Adjust according to load average
        max_nprocs = int(nprocs + self.cfg['loadavg'] - _get_loadavg() - .5)
        max_nprocs = max(1, max_nprocs)
        nprocs = min(nprocs, max_nprocs)

        # Adjust according to memory usage
        mem_max = _total_mem() * self.cfg['max_mem_percentage'] / 100.
        for j, (pid, prio) in enumerate(self.pids[:nprocs]):
            mem_max -= _mem_usage(pid)
            if mem_max < 0 and j > 0:
                nprocs = j
                break

        # Stop / continue
        to_run = self.pids[:nprocs]
        to_stop = self.pids[nprocs:]

        for pid, prio in to_run:
            _continue_process(pid)

        for pid, prio in to_stop:
            _stop_process(pid)

        self.save_pids()

    def logfile(self, pid, timestamp=None):
        if not _is_running(pid, True):
            return None
        
        if timestamp is None:
            timestamp = time.strftime('%Y-%m-%d_%H-%M-%S')

        cmdline = _nice_cmdline(pid)
        
        if cmdline:
            cmd = os.path.basename(cmdline[0])
        else:
            cmd = 'log'
            
        logfile_fn = os.path.join(
            self.cfg['logdir'], '%s.%s.%d' % (cmd, timestamp, pid))
        
        if not os.path.isfile(logfile_fn):
            f = open(logfile_fn, 'w')
            hdr = "%s\n%s\n%s\n%s\n" % (' '.join(cmdline), timestamp,
                                        os.getcwd(), "-"*79)
            f.write(hdr)
            f.close()
        
        f = open(logfile_fn, 'a')
        return f

def do_add(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.add(pid, 0)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()
    
def do_remove(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.remove(pid)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()

def do_schedule(sched, p):
    sched.schedule()

def do_setprio(sched, p):
    try:
        pid = int(p.args[0])
        prio = float(p.args[1])
    except ValueError:
        p.error("pid, prio not given")
    sched.remove(pid)
    sched.add(pid, prio)
    sched.save()

def do_list(sched, p):
    for pid, prio in sched.pids:
        mark = " "
        if _is_running(pid, False):
            mark = "*"
        elif not _is_running(pid, True):
            mark = "/"
        cmdline = ' '.join(_nice_cmdline(pid))
        if not cmdline:
            cmdline = "---"
        try:
            print "%8d%s  %.2g  %s" % (pid, mark, prio, cmdline)
        except IOError:
            return

def do_killall(sched, p):
    queue = []

    def _flush():
        for pid2 in queue:
            for k in xrange(50):
                if not _is_running(pid2): break
                time.sleep(0.05)
        for pid2 in queue:
            if _is_running(pid2):
                os.kill(pid, signal.SIGKILL)
        queue[:] = []

    for pid, prio in sched.pids:
        os.kill(pid, signal.SIGTERM)
        os.kill(pid, signal.SIGCONT)
        queue.append(pid)

        # clean
        time.sleep(0.01)
        for pid2 in queue:
            if not _is_running(pid2):
                queue.remove(pid2)

        # check if forcing flush is needed
        if len(queue) > sched.cfg['nprocs']:
            _flush()
    
    _flush()
    sched._update()

def do_tail(sched, p):
    pids = [pid for pid, prio in sched.pids]
    if p.args:
        try:
            pids = [int(pid) for pid in p.args]
        except ValueError:
            p.error('one of PIDS is not a number')
    
    files = []
    for pid in pids:
        log_glob = os.path.join(sched.cfg['logdir'], '*.%d' % (pid,))
        files.extend(glob.glob(log_glob))

    if not files:
        print "No files to tail"
        return

    for fn in files:
        print fn
        f = open(fn, 'r')
        print "    " + f.readline(),
        f.close()
    print "-"*79

    cmd = ['tail', '-f'] + files
    os.execvp(cmd[0], cmd)

def do_run(sched, p):
    sched.add(os.getpid(), p.options.priority)
    sched.save()

    os.nice(sched.cfg['nice'])
    _set_ioprio(os.getpid(), sched.cfg['ioprio'])
    _stop_process(os.getpid())
    os.execvp(p.args[0], p.args)
    raise RuntimeError("Failed to execute command '%s'" % p.args)

def do_run_bg(sched, p):
    # 1st fork
    pid = os.fork()
    if pid > 0:
        sys.exit(0)

    # invoke in background
    os.setsid()

    # 2nd fork to remove session leader status
    pid = os.fork()
    if pid > 0:
        sys.exit(0)

    # add to scheduler
    print "Added pid", os.getpid()
    sched.add(os.getpid(), p.options.priority)
    sched.save()

    # redirect output + close input
    sys.stdout.flush()
    sys.stderr.flush()
    f = sched.logfile(os.getpid())
    f2 = open(os.devnull, 'r')
    os.dup2(f2.fileno(), sys.stdin.fileno())
    os.dup2(f.fileno(), sys.stdout.fileno())
    os.dup2(f.fileno(), sys.stderr.fileno())

    # renice
    os.nice(sched.cfg['nice'])
    _set_ioprio(os.getpid(), sched.cfg['ioprio'])

    # stop and run
    _stop_process(os.getpid())
    os.execvp(p.args[0], p.args)
    raise RuntimeError("Failed to execute command '%s'" % p.args)

def main(argv):
    help = """
Process job controller, letting a limited number of jobs run at the same
time.
    
commands:
  add PID             Add a PID to the schedule list
  remove PID          Remove a PID from the schedule list
  list                List scheduled PIDs
  schedule            Perfom scheduling, starting/stopping processes
  setprio PID PRIO    Set a priority for a PID
  run CMD             Run a command and put the process in the queue
  bg CMD              Run a command in the background and insert to queue
                      Redirect the output to a file in ~/.conjob.log/
  killall             Kill all processes
""".strip()
    
    p = optparse.OptionParser("%prog [options] command [PIDS...]\n\n" + help)
    p.add_option('-p', '--priority', action='store', type=str,
                 dest='priority', default=0,
                 help="Priority for the started process")
    p.allow_interspersed_args = False
    (options, args) = p.parse_args(argv)

    if len(args) < 1:
        p.error("No command given")

    sched = PidScheduler(CFGFILE)

    cmds = dict(add=do_add,
                schedule=do_schedule,
                remove=do_remove,
                setprio=do_setprio,
                list=do_list,
                run=do_run,
                bg=do_run_bg,
                ls=do_list,
                rm=do_remove,
                tail=do_tail,
                killall=do_killall)

    cmd = args.pop(0)
    func = cmds.get(cmd)

    p.args = args
    p.options = options
    if func is None:
        p.error("Unknown command %s" % cmd)
    else:
        func(sched, p)
    
if __name__ == "__main__":
    main(sys.argv[1:])
