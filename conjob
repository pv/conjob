#!/usr/bin/env python2.5
# -*-python-*-
import os, sys, time, optparse, signal, tempfile, shutil, glob, re
import configobj

CFGFILE = os.path.expanduser("~/.conjob")

class Job(object):
    """
    Representation of a pending or running job.

    """
    date_format = '%Y-%m-%d %H:%M:%S'

    def __init__(self, jid, cmd):
        self.jid = jid
        self.process = None
        self.cmd = cmd
        self.log_file = None
        self.completed = False
        self.queue_time = datetime.datetime.now()
        self.start_time = None
        self.priority = 0.

    @classmethod
    def from_section(cls, section):
        self = Job(None, None)
        self.jid = str(section['jid'])
        pid = section.get('pid', None)
        if pid is not None:
            self.process = Process(pid)
            if not self.process.is_alive:
                self.process = None
        else:
            self.process = None
        self.cmd = section['cmd']
        self.log_file = section['log_file']
        self.completed = bool(section.get('completed', False))
        if 'start_time' in section:
            self.start_time = datetime.datetime.strptime(section['start_time'],
                                                         self.date_format)
        self.queue_time = datetime.datetime.strptime(section['queue_time'],
                                                     self.date_format)
        self.priority = float(section.get('priority', 0.))

    def as_section(self):
        section = {}
        section['jid'] = self.jid
        if self.process is not None:
            section['pid'] = self.process.pid
        if self.start_time is not None:
            section['start_time'] = self.start.time
        section['cmd'] = self.cmd
        section['log_file'] = self.log_file
        if self.completed:
            section['completed'] = True
        if self.start_time:
            section['start_time'] = self.start_time.strftime(self.date_format)
        section['queue_time'] = self.queue_time.strftime(self.date_format)
        section['priority'] = self.priority
        return section

    @property
    def active(self):
        return (self.process is not None)

    def kill(self):
        if self.active and self.process.is_alive:
            self.process.kill()
        self.completed = True
        self.process = None

    def run(self):
        if self.completed:
            return
        if self.active:
            if not self.process.is_running:
                self.process.cont()
            return

        
        

class PidScheduler(object):
    def __init__(self, filename):
        self.jobs = []
        self.cfg = configobj.ConfigObj(filename)
        self.cfg.setdefault('logdir', filename + '.log')
        self.cfg.setdefault('joblist', filename + '.jobs')
        self.cfg.setdefault('nprocs', 2)
        self.cfg.setdefault('nice', 10)
        self.cfg.setdefault('ioprio', 7)
        self.cfg.setdefault('loadavg', 2)
        self.cfg.setdefault('max_mem_percentage', 75)
        self.cfg['nice'] = int(self.cfg['nice'])
        self.cfg['ioprio'] = int(self.cfg['ioprio'])
        self.cfg['nprocs'] = int(self.cfg['nprocs'])
        self.cfg['loadavg'] = float(self.cfg['loadavg'])
        self.cfg['pidlist'] = str(self.cfg['pidlist'])
        self.cfg['logdir'] = str(self.cfg['logdir'])
        self.cfg['max_mem_percentage'] = float(self.cfg['max_mem_percentage'])
        self.load_jobs()

        if not os.path.isdir(self.cfg['logdir']):
            os.makedirs(self.cfg['logdir'])
    
    def load_jobs(self):
        cfg = configobj.ConfigObj(self.cfg['joblist'])
        for key, value in cfg.iteritems():
            self.jobs.append(Job.from_section(value))

    def save_pids(self):
        # avoid write races by writing to a temp file and overwriting
        # by moving (which probably is atomic within a FS)
        fd, tmp_fn = tempfile.mkstemp(
                prefix=os.path.basename(self.cfg['pidlist']),
                dir=os.path.dirname(self.cfg['pidlist']))
        cfg = configobj.ConfigObj()
        cfg.filename = tmp_fn
        for job in self.jobs:
            cfg[job.jid] = job.as_section()
        cfg.write()
        shutil.move(tmp_fn, self.cfg['pidlist'])

    def next_jid(self):
        imax = max([job.jid for job in self.jobs])
        return "%d" % (imax+1)

    def save(self):
        self.save_pids()
    
    def add(self, cmd):
        self.jobs.append(Job(self.next_jid(), cmd))

    def kill(self, job):
        job.kill()
        self.jobs.remove(job)

    def _update(self):
        for job in self.jobs:
            if job.process and not job.process.is_alive():
                job.completed = True

    def schedule(self):
        def _cmp_prio(a, b):
            return cmp(a.priority, b.priority)

        # Check status
        self._update()

        # Sort
        self.pids.sort(_cmp_prio, reverse=True)
        nprocs = self.cfg['nprocs']

        # Adjust according to load average
        running = len([z for z in self.jobs if z.active])
        max_nprocs = running + int(round(self.cfg['loadavg']
                                         - Process.get_loadavg()))
        max_nprocs = max(1, max_nprocs)
        nprocs = min(nprocs, max_nprocs)

        # Adjust according to memory usage
        mem_max = _total_mem() * self.cfg['max_mem_percentage'] / 100.
        for j, job in enumerate(self.jobs[:nprocs]):
            if job.active:
                mem_max -= job.process.mem_used
            else:
                mem_max -= 0.05 * _total_mem()
            if mem_max < 0 and j > 0:
                nprocs = j
                break

        # Stop / continue
        to_run = self.pids[:nprocs]
        to_stop = self.pids[nprocs:]

        for cpu, (pid, prio) in enumerate(to_run):
            _continue_process(pid)
            _set_cpu_affinity(pid, cpu % _ncpus())

        for pid, prio in to_stop:
            _stop_process(pid)

        self.save_pids()

    def logfile(self, pid, timestamp=None):
        if not _is_running(pid, True):
            return None
        
        if timestamp is None:
            timestamp = time.strftime('%Y-%m-%d_%H-%M-%S')

        cmdline = _nice_cmdline(pid)
        
        if cmdline:
            cmd = os.path.basename(cmdline[0])
        else:
            cmd = 'log'
            
        logfile_fn = os.path.join(
            self.cfg['logdir'], '%s.%s.%d' % (cmd, timestamp, pid))
        
        if not os.path.isfile(logfile_fn):
            f = open(logfile_fn, 'w')
            hdr = "%s\n%s\n%s\n%s\n" % (' '.join(cmdline), timestamp,
                                        os.getcwd(), "-"*79)
            f.write(hdr)
            f.close()
        
        f = open(logfile_fn, 'a')
        return f

def pid_list_iter(listspec, in_sched=None):
    if not isinstance(listspec, str):
        for item in listspec:
            for pid in pid_list_iter(item, in_sched):
                yield pid
        return
    
    if listspec == 'all':
        if in_sched is not None:
            for pid, prio in in_sched.pids:
                yield pid
            return
        else:
            raise ValueError()
    
    if in_sched is None:
        def check_pid(j):
            pass
    else:
        valid_pids = {}
        for pid, prio in in_sched.pids:
            valid_pids[pid] = True
        def check_pid(j):
            return j in valid_pids

    try:
        items = [x.strip() for x in listspec.split(',')]
        for item in items:
            if '-' in item:
                a, b = map(int, item.split('-'))
                for j in xrange(a, b+1, 1):
                    if check_pid(j):
                        yield j
            else:
                j = int(item)
                if check_pid(j):
                    yield j
    except ValueError:
        raise ValueError("Invalid pid list '%s'" % listspec)

def do_add(sched, p):
    try:
        for x in p.args:
            for pid in pid_list_iter(x):
                sched.add(pid, 0)
    except ValueError:
        p.error("Invalid pid %s" % x)
    sched.save()

def do_remove(sched, p):
    try:
        for x in p.args:
            for pid in pid_list_iter(x, sched):
                sched.remove(pid)
    except ValueError:
        p.error("Invalid pid %s" % x)
    sched.save()

def do_schedule(sched, p):
    sched.schedule()

def do_setprio(sched, p):
    try:
        for pid in pid_list_iter(p.args[0], sched):
            prio = float(p.args[1])
            sched.remove(pid)
            sched.add(pid, prio)
    except ValueError:
        p.error("Invalid pid/prio")
    sched.save()

def do_list(sched, p):
    for pid, prio in sched.pids:
        mark = " "
        if _is_running(pid, False):
            mark = "*"
        elif not _is_running(pid, True):
            mark = "/"
        cmdline = ' '.join(_nice_cmdline(pid))
        if not cmdline:
            cmdline = "---"
        try:
            print "%8d%s  %.2g  %s" % (pid, mark, prio, cmdline)
        except IOError:
            return

def do_kill(sched, p):
    queue = []

    def _flush():
        for pid2 in queue:
            for k in xrange(50):
                if not _is_running(pid2): break
                time.sleep(0.05)
        for pid2 in queue:
            if _is_running(pid2):
                os.kill(pid, signal.SIGKILL)
        del queue[:]

    for pid in pid_list_iter(p.args, sched):
        os.kill(pid, signal.SIGTERM)
        os.kill(pid, signal.SIGCONT)
        queue.append(pid)

        # clean
        time.sleep(0.05)
        for pid2 in queue:
            if not _is_running(pid2):
                queue.remove(pid2)

        # check if forcing flush is needed
        if len(queue) > sched.cfg['nprocs']:
            _flush()
    
    _flush()
    sched._update()

def do_tail(sched, p, base_cmd=['tail', '-f']):
    pids = list(pid_list_iter(p.args, sched))

    files = []
    for pid in pids:
        log_glob = os.path.join(sched.cfg['logdir'], '*.%d' % (pid,))
        new_files = glob.glob(log_glob)
        new_files.sort(key=lambda fn: os.stat(fn).st_mtime)
        if new_files:
            files.append(new_files[-1])

    if not files:
        print "No files to tail"
        return

    for fn in files:
        print fn
        f = open(fn, 'r')
        print "    " + f.readline(),
        f.close()
    print "-"*79
    
    cmd = base_cmd + files
    os.execvp(cmd[0], cmd)

def do_less(sched, p):
    do_tail(sched, p, ['less', '+k'])

def do_run(sched, p):
    sched.add(os.getpid(), p.options.priority)
    sched.save()

    os.nice(sched.cfg['nice'])
    _set_ioprio(os.getpid(), sched.cfg['ioprio'])
    _stop_process(os.getpid())
    os.execvp(p.args[0], p.args)
    raise RuntimeError("Failed to execute command '%s'" % p.args)

def do_run_bg(sched, p):
    # 1st fork
    pid = os.fork()
    if pid > 0:
        sys.exit(0)

    # invoke in background
    os.setsid()

    # 2nd fork to remove session leader status
    pid = os.fork()
    if pid > 0:
        sys.exit(0)

    # add to scheduler
    print "Added pid", os.getpid()
    sched.add(os.getpid(), p.options.priority)
    sched.save()

    # redirect output + close input
    sys.stdout.flush()
    sys.stderr.flush()
    f = sched.logfile(os.getpid())
    f2 = open(os.devnull, 'r')
    os.dup2(f2.fileno(), sys.stdin.fileno())
    os.dup2(f.fileno(), sys.stdout.fileno())
    os.dup2(f.fileno(), sys.stderr.fileno())

    # renice
    os.nice(sched.cfg['nice'])
    _set_ioprio(os.getpid(), sched.cfg['ioprio'])

    # stop and run
    _stop_process(os.getpid())
    os.execvp(p.args[0], p.args)
    raise RuntimeError("Failed to execute command '%s'" % p.args)

def main(argv):
    help = """
Process job controller, letting a limited number of jobs run at the same
time.
    
commands:
  add PIDS            Add a PID to the schedule list
  remove PIDS         Remove a PID from the schedule list
  list                List scheduled PIDs
  schedule            Perfom scheduling, starting/stopping processes
  setprio PIDS PRIO   Set a priority for a PID
  run CMD             Run a command and put the process in the queue
  bg CMD              Run a command in the background and insert to queue
                      Redirect the output to a file in ~/.conjob.log/
  kill PIDS           Kill processes; PIDS can also be 'all'.
  tail PIDS           Tail -f logfiles of PIDS
  less PIDS           Page through logfiles of PIDS

'PIDS' can be a comma separated list of PIDs or PID ranges, or 'all'.
""".strip()

    p = optparse.OptionParser("%prog [options] command [...]\n\n" + help)
    p.add_option('-p', '--priority', action='store', type=str,
                 dest='priority', default=0,
                 help="Priority for the started process")
    p.allow_interspersed_args = False
    (options, args) = p.parse_args(argv)

    if len(args) < 1:
        p.error("No command given")

    sched = PidScheduler(CFGFILE)

    cmds = dict(add=do_add,
                schedule=do_schedule,
                remove=do_remove,
                rm=do_remove,
                setprio=do_setprio,
                list=do_list,
                ls=do_list,
                run=do_run,
                bg=do_run_bg,
                tail=do_tail,
                less=do_less,
                kill=do_kill)

    cmd = args.pop(0)
    func = cmds.get(cmd)

    p.args = args
    p.options = options
    if func is None:
        p.error("Unknown command %s" % cmd)
    else:
        func(sched, p)

#------------------------------------------------------------------------------
# Controlling processes
#------------------------------------------------------------------------------

class Process(object):
    def __init__(self, pid):
        self.pid = pid

    def kill(self):
        os.kill(self.pid, signal.SIGTERM)

    def stop(self):
        os.kill(self.pid, signal.SIGSTOP)

    def cont(self):
        os.kill(self.pid, signal.SIGCONT)

    @property
    def mem_used(self):
        dr = '/proc/%d' % self.pid
        if os.path.isdir(dr):
            f = open('%s/status' % dr)
            try:
                lines = f.read().split("\n")
                for line in lines:
                    m = re.match(r'^VmSize:\s*(\d+) kB$', line)
                    if m:
                        return float(m.group(1))
            finally:
                f.close()
        return 0

    @property
    def is_running(self, accept_stopped=False):
        dr = '/proc/%d' % self.pid
        if os.path.isdir(dr):
            f = open('%s/stat' % dr)
            try:
                x = f.read().split()
                if accept_stopped:
                    return True
                else:
                    return (x[2] != 'T')
            finally:
                f.close()
        else:
            return False

    @property
    def is_alive(self):
        return os.path.isdir('/proc/%d' % self.pid)

    def set_ioprio(self, ioprio=0):
        """Set IO priority"""
        os.system('ionice -p %d -n %d' % (self.pid, ioprio))

    def set_cpu_affinity(self, cpu=0):
        os.system('schedtool -a %d %d' % (cpu, self.pid))

    @staticmethod
    def get_loadavg():
        f = open('/proc/loadavg', 'r')
        try:
            data = f.read()
            return float(data.split()[0])
        finally:
            f.close()

    @staticmethod
    def get_ncpus():
        f = open('/proc/cpuinfo', 'r')
        try:
            ncpus = 0
            for line in f:
                if line.startswith('processor'):
                    ncpus += 1
            return ncpus
        finally:
            f.close()

    @staticmethod
    def get_total_mem():
        f = open('/proc/meminfo', 'r')
        try:
            lines = f.read().split("\n")
            for line in lines:
                m = re.match(r'^MemTotal:\s*(\d+) kB$', line)
                if m:
                    return float(m.group(1))
        finally:
            f.close()
        return 1e99

    @classmethod
    def fork_to_background(cls, cmd, logfile, nice=None, ioprio=None):
        (pid_pipe_r, pid_pipe_w) = os.pipe()


        # p = conjob.Process.fork_to_background(['ls', '/'], '/tmp/foo.log.1')
        
        # 1st fork
        pid = os.fork()
        if pid > 0:
            # parent
            pid = int(os.read(pid_pipe_r, 64))
            os.close(pid_pipe_r)
            os.close(pid_pipe_w)
            return cls(pid)

        # invoke in background
        os.setsid()

        # 2nd fork to remove session leader status
        pid = os.fork()
        if pid > 0:
            # dummy parent
            sys.exit(0)

        self = cls(os.getpid())
        os.write(pid_pipe_w, '%d\n' % self.pid)
        os.close(pid_pipe_r)
        os.close(pid_pipe_w)

        # redirect output + close input
        sys.stdout.flush()
        sys.stderr.flush()
        if isinstance(logfile, str):
            logfile = open(logfile, 'a')
        f = logfile
        f2 = open(os.devnull, 'r')
        os.dup2(f2.fileno(), sys.stdin.fileno())
        os.dup2(f.fileno(), sys.stdout.fileno())
        os.dup2(f.fileno(), sys.stderr.fileno())

        # renice
        if nice:
            os.nice(nice)
        if ioprio:
            self.set_ioprio(ioprio)

        # stop and run
        self.stop()
        os.execvp(cmd[0], cmd)
        raise RuntimeError("Failed to execute command '%s'" % cmd)


if __name__ == "__main__":
    main(sys.argv[1:])
