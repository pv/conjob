#!/usr/bin/env python2.5
# -*-python-*-
import os, sys, time, optparse, signal, configobj, tempfile, shutil, glob
import subprocess

CFGFILE = os.path.expanduser("~/.conjob")

def _is_running(pid, accept_stopped=False):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/stat' % dr)
        try:
            x = f.read().split()
            if accept_stopped:
                return (x[2] == 'R') or (x[2] == 'T')
            else:
                return (x[2] == 'R')
        finally:
            f.close()
    else:
        return False

def _cmdline(pid):
    dr = '/proc/%d' % pid
    if os.path.isdir(dr):
        f = open('%s/cmdline' % dr)
        try:
            cmdline = f.read().split("\0")
            if cmdline[-1] == '':
                cmdline.pop()
            return cmdline
        finally:
            f.close()
    else:
        return []

def _stop_process(pid):
    os.kill(pid, signal.SIGSTOP)

def _continue_process(pid):
    os.kill(pid, signal.SIGCONT)

class PidScheduler(object):
    def __init__(self, filename):
        self.pids = []
        self.cfg = configobj.ConfigObj(filename)
        self.cfg.setdefault('logdir', filename + '.log')
        self.cfg.setdefault('pidlist', filename + '.pids')
        self.cfg.setdefault('nprocs', 2)
        self.cfg.setdefault('nice', 10)
        self.cfg['nice'] = int(self.cfg['nice'])
        self.cfg['nprocs'] = int(self.cfg['nprocs'])
        self.cfg['pidlist'] = str(self.cfg['pidlist'])
        self.cfg['logdir'] = str(self.cfg['logdir'])
        self.load_pids()

        if not os.path.isdir(self.cfg['logdir']):
            os.makedirs(self.cfg['logdir'])
    
    def load_pids(self):
        cfg = configobj.ConfigObj(self.cfg['pidlist'])
        for key, value in cfg.iteritems():
            try:
                pid = int(key)
                priority = float(value)
                self.pids.append((pid, priority))
            except ValueError:
                continue

    def save_pids(self):
        # avoid write races by writing to a temp file and overwriting
        # by moving (which probably is atomic within a FS)
        fd, tmp_fn = tempfile.mkstemp(
                prefix=os.path.basename(self.cfg['pidlist']),
                dir=os.path.dirname(self.cfg['pidlist']))
        cfg = configobj.ConfigObj()
        cfg.filename = tmp_fn
        for pid, prio in self.pids:
            cfg[str(pid)] = prio
        cfg.write()
        shutil.move(tmp_fn, self.cfg['pidlist'])

    def save(self):
        self.save_pids()
    
    def add(self, pid, prio):
        for i, (key, value) in enumerate(self.pids):
            if key == pid:
                self.pids[i] = (pid, prio)
                return
        self.pids.append((pid, prio))

    def remove(self, pid):
        vals = [z for z in self.pids if z[0] == pid]
        if vals:
            for v in vals:
                self.pids.remove(v)

    def _update(self):
        self.pids = [z for z in self.pids if _is_running(z[0], True)]

    def schedule(self):
        def _cmp_prio(a, b):
            return cmp(a[1], b[1])

        # Check status
        self._update()

        # Sort
        self.pids.sort(_cmp_prio, reverse=True)
        nprocs = self.cfg['nprocs']

        # Stop / continue
        to_run = self.pids[:nprocs]
        to_stop = self.pids[nprocs:]

        for pid, prio in to_run:
            _continue_process(pid)

        for pid, prio in to_stop:
            _stop_process(pid)

        self.save_pids()

    def logfile(self, pid, timestamp=None):
        cmdline = _cmdline(pid)
        if not _is_running(pid, True):
            return None
        
        if timestamp is None:
            timestamp = time.strftime('%Y-%m-%d_%H-%M-%S')

        for arg in (sys.argv[0], 'conjob'):
            if arg in cmdline:
                cmdline = cmdline[cmdline.index(arg)+2:]
                break
        
        if cmdline and cmdline[0].startswith('python2.'):
            cmdline.pop(0)
        
        if cmdline:
            cmd = os.path.basename(cmdline[0])
        else:
            cmd = 'log'
            
        logfile_fn = os.path.join(
            self.cfg['logdir'], '%s.%s.%d' % (cmd, timestamp, pid))
        
        if not os.path.isfile(logfile_fn):
            f = open(logfile_fn, 'w')
            hdr = "%s\n%s\n%s\n%s\n" % (' '.join(cmdline), timestamp,
                                        os.getcwd(), "-"*79)
            f.write(hdr)
            f.close()
        
        f = open(logfile_fn, 'a')
        return f

def do_add(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.add(pid, 0)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()
    
def do_remove(sched, p):
    for x in p.args:
        try:
            pid = int(x)
            sched.remove(pid)
        except ValueError:
            p.error("Invalid pid %s" % x)
    sched.save()

def do_schedule(sched, p):
    sched.schedule()

def do_setprio(sched, p):
    try:
        pid = int(p.args[0])
        prio = float(p.args[1])
    except ValueError:
        p.error("pid, prio not given")
    sched.remove(pid)
    sched.add(pid, prio)
    sched.save()

def do_list(sched, p):
    for pid, prio in sched.pids:
        mark = " "
        if _is_running(pid, False):
            mark = "*"
        elif not _is_running(pid, True):
            continue
        cmdline = ' '.join(_cmdline(pid))
        print "%8d%s  %.2g  %s" % (pid, mark, prio, cmdline)

def do_tail(sched, p):
    pids = [pid for pid, prio in sched.pids]
    if p.args:
        try:
            pids = [int(pid) for pid in p.args]
        except ValueError:
            p.error('one of PIDS is not a number')
    
    files = []
    for pid in pids:
        log_glob = os.path.join(sched.cfg['logdir'], '*.%d' % (pid,))
        files.extend(glob.glob(log_glob))

    if not files:
        print "No files to tail"
        return

    for fn in files:
        print fn
        f = open(fn, 'r')
        print "    " + f.readline(),
        f.close()
    print "-"*79

    subprocess.call(['tail', '-f'] + files)

def do_run(sched, p):
    parent_pid = os.getpid()
    pid = os.fork()
    if pid < 0:
        raise RuntimeError("Failed to fork the process")
    elif pid == 0:
        # child
        print "Adding job PID %d" % parent_pid
        sched.add(parent_pid, p.options.priority)
        sched.save()
        sys.exit(0)
    else:
        # parent (we purposefully exec the code here so that we properly
        # retain the controlling terminal)
        _stop_process(os.getpid())
        os.nice(sched.cfg['nice'])
        os.execvp(p.args[0], p.args)
        raise RuntimeError("Failed to execute command '%s'" % p.args)

def do_run_bg(sched, p):
    pid = os.fork()
    if pid < 0:
        raise RuntimeError("Failed to fork the process")
    elif pid == 0:
        # child
        time.sleep(0.1)
        
        # invoke in background
        os.setsid()

        # redirect output + close input
        f = sched.logfile(os.getpid())
        sys.stdout.flush()
        sys.stderr.flush()
        sys.stdin.close()
        os.dup2(f.fileno(), sys.stdout.fileno())
        os.dup2(f.fileno(), sys.stderr.fileno())

        # run command
        os.nice(sched.cfg['nice'])
        os.execvp(p.args[0], p.args)
        raise RuntimeError("Failed to execute command '%s'" % p.args)
    else:
        # parent
        #_stop_process(pid)
        print "Adding job PID %d" % pid
        sched.add(pid, p.options.priority)
        sched.save()
        sys.exit(0)
        
def main(argv):
    help = """
Process job controller, letting a limited number of jobs run at the same
time.
    
commands:
  add PID             Add a PID to the schedule list
  remove PID          Remove a PID from the schedule list
  list                List scheduled PIDs
  schedule            Perfom scheduling, starting/stopping processes
  setprio PID PRIO    Set a priority for a PID
  run CMD             Run a command and put the process in the queue
  bg CMD              Run a command in the background and insert to queue
                      Redirect the output to a file in ~/.conjob.log/
""".strip()
    
    p = optparse.OptionParser("%prog [options] command [PIDS...]\n\n" + help)
    p.add_option('-p', '--priority', action='store', type=str,
                 dest='priority', default=0,
                 help="Priority for the started process")
    p.allow_interspersed_args = False
    (options, args) = p.parse_args(argv)

    if len(args) < 1:
        p.error("No command given")

    sched = PidScheduler(CFGFILE)

    cmds = dict(add=do_add,
                schedule=do_schedule,
                remove=do_remove,
                setprio=do_setprio,
                list=do_list,
                run=do_run,
                bg=do_run_bg,
                ls=do_list,
                rm=do_remove,
                tail=do_tail)

    cmd = args.pop(0)
    func = cmds.get(cmd)

    p.args = args
    p.options = options
    if func is None:
        p.error("Unknown command %s" % cmd)
    else:
        func(sched, p)
    
if __name__ == "__main__":
    main(sys.argv[1:])
